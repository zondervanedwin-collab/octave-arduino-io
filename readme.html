<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>octave-arduino-io — README</title>
  <style>
    :root { color-scheme: light dark; }
    body {
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      line-height: 1.5;
      margin: 0;
      padding: 2rem;
      max-width: 980px;
    }
    h1, h2, h3 { line-height: 1.2; }
    h1 { margin-top: 0; }
    code, pre {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }
    pre {
      padding: 1rem;
      border-radius: 10px;
      overflow-x: auto;
      border: 1px solid rgba(127,127,127,0.35);
    }
    code {
      padding: 0.1rem 0.25rem;
      border-radius: 6px;
      border: 1px solid rgba(127,127,127,0.25);
    }
    pre code { padding: 0; border: 0; }
    blockquote {
      margin: 1rem 0;
      padding: 0.75rem 1rem;
      border-left: 4px solid rgba(127,127,127,0.5);
      background: rgba(127,127,127,0.08);
      border-radius: 8px;
    }
    hr { border: 0; border-top: 1px solid rgba(127,127,127,0.35); margin: 2rem 0; }
    table {
      border-collapse: collapse;
      width: 100%;
      margin: 1rem 0;
    }
    th, td {
      text-align: left;
      padding: 0.5rem 0.75rem;
      border: 1px solid rgba(127,127,127,0.35);
      vertical-align: top;
    }
    .note {
      padding: 0.75rem 1rem;
      border-radius: 10px;
      border: 1px solid rgba(255, 165, 0, 0.6);
      background: rgba(255, 165, 0, 0.12);
      margin: 1rem 0;
    }
    .small { opacity: 0.9; font-size: 0.95rem; }
  </style>
</head>
<body>

  <h1>octave-arduino-io</h1>

  <p><strong>A minimal, transparent Octave ↔ Arduino I/O interface based on serial communication.</strong></p>

  <p><code>octave-arduino-io</code> provides a clean and robust way to control <strong>Arduino digital and analog I/O directly from GNU Octave</strong>,
  without relying on the fragile and board-limited Octave <code>arduino()</code> package.</p>

  <blockquote>
    <p><strong>Octave handles logic and control.<br>
    Arduino handles hardware.<br>
    Communication is explicit and transparent.</strong></p>
  </blockquote>

  <hr>

  <h2>Why this package exists</h2>

  <p>The official Octave <code>arduino</code> package:</p>
  <ul>
    <li>supports only a limited set of boards,</li>
    <li>relies on hidden firmware,</li>
    <li>is difficult to debug,</li>
    <li>and often breaks across architectures (AVR vs SAMD, clones, etc.).</li>
  </ul>

  <p>This package instead:</p>
  <ul>
    <li>uses <strong>plain serial communication</strong>,</li>
    <li>works on <strong>Arduino Uno, clones, MKR, and others</strong>,</li>
    <li>exposes <strong>exactly what is sent and received</strong>,</li>
    <li>and is ideal for <strong>education, labs, and control experiments</strong>.</li>
  </ul>

  <hr>

  <h2>Architecture overview</h2>

  <pre><code>Octave (PC)            Arduino (microcontroller)
------------------------------------------------
Control logic     --&gt;  Serial commands
Timing            --&gt;  Hardware I/O
Data processing   &lt;--  Sensor values</code></pre>

  <p>Octave never touches hardware pins directly.<br>
  Arduino never performs control logic.</p>

  <p>This mirrors real industrial control systems (controller ↔ field device).</p>

  <hr>

  <h2>Features</h2>
  <ul>
    <li>Digital output (<code>digitalWrite</code>)</li>
    <li>Digital input (<code>digitalRead</code>)</li>
    <li>Analog input (<code>analogRead</code>)</li>
    <li>PWM output (<code>analogWrite</code>)</li>
    <li>Explicit <code>pinMode</code></li>
    <li>Binary protocol (fast and reliable)</li>
    <li>Single serial connection</li>
    <li>No hidden state between sessions</li>
    <li>Depends only on <code>instrument-control</code></li>
  </ul>

  <hr>

  <h2>Supported hardware</h2>

  <p>Tested and working on:</p>
  <ul>
    <li>Arduino Uno (including CH340 clones)</li>
    <li>Arduino MKR WiFi 1010</li>
  </ul>

  <p>Likely works on:</p>
  <ul>
    <li>Any Arduino-compatible board with USB serial</li>
  </ul>

  <hr>

  <h2>Folder structure</h2>

  <pre><code>octave-arduino-io/
├── firmware/
│   └── octave_arduino_io.ino
├── octave/
│   ├── arduino_init.m
│   ├── open_arduino_serial.m
│   ├── dwrite.m
│   ├── dread.m
│   ├── aread.m
│   ├── pinmode.m
│   ├── analogwrite.m
│   ├── writeDigitalPin.m   (optional alias)
│   └── readDigitalPin.m    (optional alias)
├── examples/
│   ├── blink_builtin_led.m
│   ├── pwm_fade.m
│   └── pot_to_pwm.m
└── README.html</code></pre>

  <hr>

  <h2>Installation</h2>

  <h3>1. Arduino side</h3>
  <ol>
    <li>Open the Arduino IDE</li>
    <li>Load the firmware:
      <pre><code>firmware/octave_arduino_io.ino</code></pre>
    </li>
    <li>Select the correct board and port</li>
    <li>Upload the sketch</li>
  </ol>

  <div class="note">
    <strong>Important:</strong> Close the Arduino Serial Monitor after uploading.<br>
    The firmware is stored in flash and <strong>persists across power cycles and reboots</strong>.
  </div>

  <h3>2. Octave side</h3>
  <p>Ensure the instrument-control package is installed:</p>

  <pre><code>pkg install -forge instrument-control   % once
pkg load instrument-control</code></pre>

  <p>Add the <code>octave/</code> folder to your Octave path, or work from that directory.</p>

  <hr>

  <h2>Automatic initialization (recommended)</h2>

  <p>To make the package robust across:</p>
  <ul>
    <li>unplug / replug,</li>
    <li>Octave restarts,</li>
    <li>system reboots,</li>
  </ul>
  <p><code>octave-arduino-io</code> provides an <strong>automatic initialization routine</strong>.</p>

  <h3>Initialization function</h3>
  <p>The function <code>arduino_init.m</code>:</p>
  <ul>
    <li>scans available serial ports,</li>
    <li>selects a USB/ACM device (typical for Arduino),</li>
    <li>opens the serial connection,</li>
    <li>waits for the Arduino reset,</li>
    <li>flushes any startup bytes.</li>
  </ul>

  <p>No hard-coded <code>/dev/ttyUSB0</code> or <code>/dev/ttyACM0</code> is required.</p>

  <h3>Usage</h3>
  <pre><code>s = arduino_init();</code></pre>

  <p class="small">By default, the baud rate is <strong>115200</strong>, matching the firmware.</p>

  <h3>What <code>arduino_init</code> does (conceptually)</h3>

  <pre><code>1. Detect available serial ports
2. Select an Arduino-like port (ttyUSB / ttyACM)
3. Open the serial connection
4. Wait for Arduino reset
5. Flush any startup data</code></pre>

  <p>This behavior is explicit and predictable — no hidden heuristics.</p>

  <h3>Manual port selection (optional)</h3>
  <pre><code>serialportlist
s = open_arduino_serial("/dev/ttyUSB1", 115200);</code></pre>

  <hr>

  <h2>Built-in LED (Arduino Uno)</h2>

  <p>On the <strong>Arduino Uno</strong>, the built-in LED is on <strong>digital pin 13</strong>.</p>

  <pre><code>LED_BUILTIN = 13;

s = arduino_init();
pinmode(s, LED_BUILTIN, "output");

for k = 1:10
  dwrite(s, LED_BUILTIN, 1); pause(1);
  dwrite(s, LED_BUILTIN, 0); pause(1);
end

clear s</code></pre>

  <hr>

  <h2>Digital I/O</h2>

  <h3>Digital write</h3>
  <pre><code>pinmode(s, 12, "output");
dwrite(s, 12, 1);   % HIGH
dwrite(s, 12, 0);   % LOW</code></pre>

  <p class="small">(Equivalent aliases: <code>writeDigitalPin</code>, <code>readDigitalPin</code>)</p>

  <h3>Digital read</h3>
  <pre><code>v = dread(s, 7);          % returns 0 or 1
v = readDigitalPin(s, 7); % alias</code></pre>

  <hr>

  <h2>Analog input</h2>

  <p>Analog inputs are addressed as follows:</p>

  <table>
    <thead>
      <tr><th>Octave call</th><th>Arduino pin</th></tr>
    </thead>
    <tbody>
      <tr><td><code>aread(s,0)</code></td><td>A0</td></tr>
      <tr><td><code>aread(s,1)</code></td><td>A1</td></tr>
      <tr><td><code>aread(s,2)</code></td><td>A2</td></tr>
      <tr><td><code>aread(s,3)</code></td><td>A3</td></tr>
      <tr><td><code>aread(s,4)</code></td><td>A4</td></tr>
      <tr><td><code>aread(s,5)</code></td><td>A5</td></tr>
    </tbody>
  </table>

  <p>Example:</p>
  <pre><code>x = aread(s, 0);    % 0..1023 from A0</code></pre>

  <hr>

  <h2>PWM output</h2>

  <p>PWM is available on Arduino Uno pins: <strong>3, 5, 6, 9, 10, 11</strong></p>

  <pre><code>pinmode(s, 9, "output");
analogwrite(s, 9, 128);   % ~50% duty cycle</code></pre>

  <hr>

  <h2>Example: potentiometer → LED brightness</h2>

  <pre><code>s = arduino_init();

pinmode(s, 9, "output");

while true
  x = aread(s, 0);              % A0
  u = round(255 * x / 1023);    % scale
  analogwrite(s, 9, u);
  pause(0.02);
end</code></pre>

  <hr>

  <h2>Closing the connection</h2>

  <pre><code>clear s</code></pre>

  <p>This cleanly closes the serial connection.</p>

  <hr>

  <h2>Design philosophy</h2>

  <ul>
    <li>No hidden magic</li>
    <li>No automatic reflashing</li>
    <li>No board-specific hacks</li>
    <li>Everything inspectable and explainable</li>
  </ul>

  <p>This makes <code>octave-arduino-io</code> especially suitable for:</p>
  <ul>
    <li>control education</li>
    <li>numerical methods labs</li>
    <li>hardware-in-the-loop experiments</li>
    <li>student projects</li>
  </ul>

  <hr>

  <h2>License</h2>

  <p>Open for educational and research use.<br>
  Feel free to adapt and extend.</p>

  <hr>

  <h2>Acknowledgements</h2>

  <p>Developed through iterative debugging, teaching needs, and a strong preference for
  <strong>clarity over convenience</strong>.</p>

</body>
</html>

